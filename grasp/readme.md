#GRASP

* Information expert

Проблема - в системе должна аккумулироваться и рассчитываться необходимая информация  
Решение - назначить обязанность расчета некоему классу, обладающему необходимой информацией  
Рекомендации - информацияонным экспертом может быть не один класс, а несколько  

Никакая часть системы не должна обрабатывать информацию хранящаюся в другой части системы

* Creator - Создатель экземпляров класса, [видео](https://youtu.be/cY9nFsx4q0I?t=50m58s)

Проблема - кто должен отвечать за создание экземплялор класса  
Решение - назначить классу B обязанность создавать объекты класса A  
Рекомендации - логично использовать паттерн, если класс B активно использует класс A  

Преимущества - не повышает связности, поскольку созданный класс виден только для класса-создателя  
Недостатки - если процедура создания объекта достаточно сложная, логично использовать 
    паттерн "Абстрактная фабрика"
    
    
Конструктор - точно такой же метод, создающий зависимость


* Controller - [видео](https://youtu.be/jw3f8OrjYT0?t=6m18s)

Проблема - "Кто" должен отвечать за обработку входных системных событий
Решение - обязанность делегируется специальному классу. Констроллер это объект, который
    отвечает за обработку событий и не относится к интерфейсу пользователя. Определяет 
    методы для выполнения системных операций
    
    
Преимущества - удобно накапливать информацию о событиях, улучшаются условия для повторного
    использования компонентов  
Недостатки - может оказаться перегруженным


* Low coupling - низкая связнность, [видео](https://youtu.be/jw3f8OrjYT0?t=20m28s)

Проблема: обеспечить низкую связность при создании экземпляра класса и связывании его с другим классом  
Решение: расперелить обязанности между между объектами так, чтобы степень связнности 
    оставалось низкой
    
    
* High cohesion - высокое зацепление

Проблема: необходимо обеспечить выполнение объектами разнородных функций
    (распределить функции по множеству объектов)
Решение: обеспечить распределение обязанностей с высоким зацеплением
    (сделать так, чтобы каждый класс отвечал за свою функцию)
    
Преимущества: классы с высокой степенью зацепления просты в поддержке и повторном использовании  
Недостатки: ???

Наличие префиксов у методов - гарантированное нарушение


* Polymorphism - полиморфизм, [видео](https://youtu.be/UxXsCS6fbJ0)

Проблема: как обрабатывать альтернативные варианты поведения на основе типа, как заменять
    подключаемые компоненты системы
Решение: обязанности распределяются с помощью полиморфных операций для этого класса, каждая
    внешняя система имеет свой интерфейс
    
Преимущества: легко расширять и модернизировать систему

Никогда не обращаться к классу напрямую, только через интерфейс


* Pure Fabrication - искуственный, [видео](https://youtu.be/UxXsCS6fbJ0?t=13m36s)

Проблема: какой класс должен обеспечить реализацию паттернов _Low coupling_ и _High cohesion_


* Indirection - перенаправление, [видео](https://youtu.be/UxXsCS6fbJ0?t=17m12s)

Проблема: как перераспределить обязанности объектов чтобы обеспечить отсутсвие прямого связывания
Решение: присвоить обязанности по обеспечению связи промежуточному объекту


* Protected variation - устойчивый к изменениям, [видео](https://youtu.be/UxXsCS6fbJ0?t=27m45s)

Проблема: как спроектировать систему так, чтобы изменение одних ее элементов не влияло на другие
Решение: идентифицировать точки возможных изменений и распределить обязанности таким образом, чтобы
    обеспечить устойчивую работу системы
    
=
* Все данные должны обрабатываться там, где они находятся
* Создание объекта является точно таким же вызовом функции
* Все входящие воздействия должны быть собраны в один единый класс
* В системе должно быть минимум связей между частями системы
* Каждая из частей системы должна быть внутренне "зацеплена" сама с собой
* 